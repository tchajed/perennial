(* autogenerated from github.com/tchajed/simplefs/filesys *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.tchajed.simplefs.
From Goose Require github_com.tchajed.simplefs.alloc.
From Goose Require github_com.tchajed.simplefs.directory.
From Goose Require github_com.tchajed.simplefs.inode.
From Goose Require github_com.tchajed.simplefs.superblock.

From Perennial.goose_lang Require Import ffi.disk_prelude.

(* block_fs.go *)

Definition blockFs := struct.decl [
  "sb" :: ptrT;
  "d" :: disk.Disk;
  "ba" :: ptrT;
  "ia" :: ptrT
].

(* Zero the relevant parts of the disk and write the superblock. *)
Definition zeroDisk: val :=
  rec: "zeroDisk" "d" "sz" :=
    let: "sb" := superblock.InitSuperblock "sz" in
    disk.Write #0 (superblock.Superblock__Encode "sb");;
    let: "zero_blk" := NewSlice byteT disk.BlockSize in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (struct.loadF superblock.Superblock "InodeBlocks" "sb")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      disk.Write ((superblock.Superblock__InodeStart "sb") + (![uint64T] "i")) "zero_blk";;
      Continue);;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (struct.loadF superblock.Superblock "DataBitmapBlocks" "sb")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      disk.Write ((superblock.Superblock__DataBitmapStart "sb") + (![uint64T] "i")) "zero_blk";;
      Continue);;
    "sb".

Definition mkBlockFs: val :=
  rec: "mkBlockFs" "d" "sz" :=
    let: "sb" := zeroDisk "d" "sz" in
    let: "root_inode" := inode.NewInode simplefs.DirType in
    inode.Inode__SetMeta "root_inode" (struct.mk inode.Meta [
      "Mode" ::= #(U32 493)
    ]);;
    inode.Inode__Write "root_inode" "d" "sb" simplefs.ROOT_INUM;;
    #().

Definition loadBlockFs: val :=
  rec: "loadBlockFs" "d" :=
    let: "sb" := superblock.LoadSuperblock "d" in
    let: "ba" := alloc.NewBlockAllocator "d" "sb" in
    let: "ia" := alloc.NewInodeAllocator "d" "sb" in
    struct.new blockFs [
      "sb" ::= "sb";
      "d" ::= "d";
      "ba" ::= "ba";
      "ia" ::= "ia"
    ].

Definition blockFs__Superblock: val :=
  rec: "blockFs__Superblock" "fs" :=
    struct.loadF blockFs "sb" "fs".

(* AllocInode allocates a new inode of the given type. Its length, meta, and
   block pointers are all guaranteed to be zeroed. *)
Definition blockFs__AllocInode: val :=
  rec: "blockFs__AllocInode" "fs" "ty" :=
    alloc.InodeAllocator__Alloc (struct.loadF blockFs "ia" "fs") "ty".

Definition blockFs__FreeInode: val :=
  rec: "blockFs__FreeInode" "fs" "i" :=
    alloc.InodeAllocator__Free (struct.loadF blockFs "ia" "fs") "i";;
    let: "ino" := inode.ReadInode (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < inode.NUM_BLOCK_PTRS); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "b" := inode.Inode__GetBlockPtr "ino" (![uint64T] "i") in
      (if: "b" ≠ #(U32 0)
      then
        alloc.BlockAllocator__Free (struct.loadF blockFs "ba" "fs") "b";;
        Continue
      else Continue));;
    let: "zero_inode" := inode.NewInode simplefs.Invalid in
    inode.Inode__Write "zero_inode" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i";;
    #().

(* GetInode reads the given inode. Only intended to expose the inode length and
   meta - type and block pointers are handled by `BlockFs`. *)
Definition blockFs__GetInode: val :=
  rec: "blockFs__GetInode" "fs" "i" :=
    inode.ReadInode (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i".

(* Update an inode to change its length and meta. *)
Definition blockFs__WriteInode: val :=
  rec: "blockFs__WriteInode" "fs" "i" "ino" :=
    inode.Inode__Write "ino" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i";;
    #().

Definition blockFs__getBlockNum: val :=
  rec: "blockFs__getBlockNum" "fs" "i" "off" :=
    (if: "off" ≥ inode.NUM_DIRECT
    then #(U32 0)
    else
      let: "ino" := inode.ReadInode (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i" in
      inode.Inode__GetBlockPtr "ino" "off").

Definition blockFs__ReadBlock: val :=
  rec: "blockFs__ReadBlock" "fs" "i" "off" :=
    let: "blkPtr" := blockFs__getBlockNum "fs" "i" "off" in
    (if: "blkPtr" = #(U32 0)
    then NewSlice byteT disk.BlockSize
    else disk.Read ((superblock.Superblock__DataStart (struct.loadF blockFs "sb" "fs")) + (to_u64 "blkPtr"))).

Definition blockFs__allocBlockNum: val :=
  rec: "blockFs__allocBlockNum" "fs" "i" "off" :=
    let: "blkPtr" := blockFs__getBlockNum "fs" "i" "off" in
    (if: "blkPtr" ≠ #(U32 0)
    then ("blkPtr", #true)
    else
      let: ("blkPtr2", "ok") := alloc.BlockAllocator__Alloc (struct.loadF blockFs "ba" "fs") in
      (if: (~ "ok")
      then (#(U32 0), #false)
      else
        let: "ino" := inode.ReadInode (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i" in
        inode.Inode__SetBlockPtr "ino" "off" "blkPtr2";;
        inode.Inode__Write "ino" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i";;
        ("blkPtr2", #true))).

Definition blockFs__WriteBlock: val :=
  rec: "blockFs__WriteBlock" "fs" "i" "off" "b" :=
    let: ("blkPtr", "ok") := blockFs__allocBlockNum "fs" "i" "off" in
    (if: (~ "ok")
    then Panic "out of space"
    else #());;
    disk.Write ((superblock.Superblock__DataStart (struct.loadF blockFs "sb" "fs")) + (to_u64 "blkPtr")) "b";;
    #().

(* byte_fs.go *)

Definition byteFs := struct.decl [
  "fs" :: struct.t blockFs
].

Definition newByteFs: val :=
  rec: "newByteFs" "fs" :=
    struct.mk byteFs [
      "fs" ::= "fs"
    ].

Definition byteFs__Superblock: val :=
  rec: "byteFs__Superblock" "b" :=
    blockFs__Superblock (struct.loadF byteFs "fs" "b").

Definition byteFs__AllocInode: val :=
  rec: "byteFs__AllocInode" "b" "ty" :=
    blockFs__AllocInode (struct.loadF byteFs "fs" "b") "ty".

Definition byteFs__FreeInode: val :=
  rec: "byteFs__FreeInode" "b" "i" :=
    blockFs__FreeInode (struct.loadF byteFs "fs" "b") "i";;
    #().

Definition byteFs__GetInode: val :=
  rec: "byteFs__GetInode" "b" "i" :=
    blockFs__GetInode (struct.loadF byteFs "fs" "b") "i".

Definition byteFs__WriteInode: val :=
  rec: "byteFs__WriteInode" "b" "i" "in" :=
    blockFs__WriteInode (struct.loadF byteFs "fs" "b") "i" "in";;
    #().

Definition byteFs__readWithinBlock: val :=
  rec: "byteFs__readWithinBlock" "b" "i" "off" "buf" :=
    (if: (~ ((#0 < (slice.len "buf")) && ((slice.len "buf") ≤ (disk.BlockSize - ("off" `rem` disk.BlockSize)))))
    then Panic "readWithinBlock precondition violated: read must be in one block"
    else #());;
    (if: (("off" `rem` disk.BlockSize) = #0) && ((slice.len "buf") = disk.BlockSize)
    then
      let: "blkRead" := blockFs__ReadBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) in
      SliceCopy byteT "buf" "blkRead";;
      #()
    else
      let: "blkRead" := blockFs__ReadBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) in
      SliceCopy byteT "buf" (SliceSubslice byteT "blkRead" ("off" `rem` disk.BlockSize) (("off" `rem` disk.BlockSize) + (slice.len "buf")));;
      #()).

(* readTillAligned reads from inode i starting at currOff, up to a block
   boundary (or less if fewer bytes are requested), filling buf and returning
   the number of bytes read *)
Definition byteFs__readTillAligned: val :=
  rec: "byteFs__readTillAligned" "b" "i" "currOff" "buf" :=
    control.impl.Assert (("currOff" `rem` disk.BlockSize) ≠ #0);;
    let: "toRead" := disk.BlockSize - ("currOff" `rem` disk.BlockSize) in
    (if: (slice.len "buf") < "toRead"
    then
      byteFs__readWithinBlock "b" "i" "currOff" "buf";;
      slice.len "buf"
    else
      byteFs__readWithinBlock "b" "i" "currOff" (SliceTake "buf" "toRead");;
      "toRead").

Definition byteFs__Read: val :=
  rec: "byteFs__Read" "b" "i" "off" "buf" :=
    let: "currOff" := ref_to uint64T "off" in
    let: "bufOff" := ref_to uint64T #0 in
    let: "remaining" := ref_to uint64T (slice.len "buf") in
    (if: (![uint64T] "remaining") = #0
    then #()
    else
      (if: ((![uint64T] "currOff") `rem` disk.BlockSize) ≠ #0
      then
        let: "n" := byteFs__readTillAligned "b" "i" (![uint64T] "currOff") "buf" in
        "currOff" <-[uint64T] ((![uint64T] "currOff") + "n");;
        "bufOff" <-[uint64T] ((![uint64T] "bufOff") + "n");;
        "remaining" <-[uint64T] ((![uint64T] "remaining") - "n")
      else #());;
      (if: (![uint64T] "remaining") = #0
      then #()
      else
        control.impl.Assert (((![uint64T] "currOff") `rem` disk.BlockSize) = #0);;
        Skip;;
        (for: (λ: <>, (![uint64T] "remaining") ≥ disk.BlockSize); (λ: <>, Skip) := λ: <>,
          byteFs__readWithinBlock "b" "i" (![uint64T] "currOff") (SliceSubslice byteT "buf" (![uint64T] "bufOff") ((![uint64T] "bufOff") + disk.BlockSize));;
          "currOff" <-[uint64T] ((![uint64T] "currOff") + disk.BlockSize);;
          "bufOff" <-[uint64T] ((![uint64T] "bufOff") + disk.BlockSize);;
          "remaining" <-[uint64T] ((![uint64T] "remaining") - disk.BlockSize);;
          Continue);;
        (if: ((![uint64T] "remaining") < disk.BlockSize) && ((![uint64T] "remaining") > #0)
        then
          byteFs__readWithinBlock "b" "i" (![uint64T] "currOff") (SliceSkip byteT "buf" (![uint64T] "bufOff"));;
          #()
        else #()))).

Definition byteFs__writeWithinBlock: val :=
  rec: "byteFs__writeWithinBlock" "b" "i" "off" "buf" :=
    (if: (~ ((#0 < (slice.len "buf")) && ((slice.len "buf") ≤ (disk.BlockSize - ("off" `rem` disk.BlockSize)))))
    then Panic "write_within_block precondition violated: write must be in one block"
    else #());;
    (if: (("off" `rem` disk.BlockSize) = #0) && ((slice.len "buf") = disk.BlockSize)
    then
      blockFs__WriteBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) "buf";;
      #()
    else
      let: "blk" := blockFs__ReadBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) in
      SliceCopy byteT (SliceSkip byteT "blk" ("off" `rem` disk.BlockSize)) "buf";;
      blockFs__WriteBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) "blk";;
      #()).

(* writeTillAligned writes data in buf to inode i starting at currOff, up to a
   block boundary (or less if fewer bytes are requested), returning the number
   of bytes written *)
Definition byteFs__writeTillAligned: val :=
  rec: "byteFs__writeTillAligned" "b" "i" "currOff" "buf" :=
    control.impl.Assert (("currOff" `rem` disk.BlockSize) ≠ #0);;
    let: "toWrite" := disk.BlockSize - ("currOff" `rem` disk.BlockSize) in
    (if: (slice.len "buf") < "toWrite"
    then
      byteFs__writeWithinBlock "b" "i" "currOff" "buf";;
      slice.len "buf"
    else
      byteFs__writeWithinBlock "b" "i" "currOff" (SliceTake "buf" "toWrite");;
      "toWrite").

Definition byteFs__Write: val :=
  rec: "byteFs__Write" "b" "i" "off" "buf" :=
    let: "currOff" := ref_to uint64T "off" in
    let: "bufOff" := ref_to uint64T #0 in
    let: "remaining" := ref_to uint64T (slice.len "buf") in
    (if: (![uint64T] "remaining") = #0
    then #()
    else
      (if: ((![uint64T] "currOff") `rem` disk.BlockSize) ≠ #0
      then
        let: "n" := byteFs__writeTillAligned "b" "i" (![uint64T] "currOff") "buf" in
        "currOff" <-[uint64T] ((![uint64T] "currOff") + "n");;
        "bufOff" <-[uint64T] ((![uint64T] "bufOff") + "n");;
        "remaining" <-[uint64T] ((![uint64T] "remaining") - "n")
      else #());;
      (if: (![uint64T] "remaining") = #0
      then #()
      else
        control.impl.Assert (((![uint64T] "currOff") `rem` disk.BlockSize) = #0);;
        Skip;;
        (for: (λ: <>, (![uint64T] "remaining") ≥ disk.BlockSize); (λ: <>, Skip) := λ: <>,
          byteFs__writeWithinBlock "b" "i" (![uint64T] "currOff") (SliceSubslice byteT "buf" (![uint64T] "bufOff") ((![uint64T] "bufOff") + disk.BlockSize));;
          "currOff" <-[uint64T] ((![uint64T] "currOff") + disk.BlockSize);;
          "bufOff" <-[uint64T] ((![uint64T] "bufOff") + disk.BlockSize);;
          "remaining" <-[uint64T] ((![uint64T] "remaining") - disk.BlockSize);;
          Continue);;
        (if: ((![uint64T] "remaining") < disk.BlockSize) && ((![uint64T] "remaining") > #0)
        then
          byteFs__writeWithinBlock "b" "i" (![uint64T] "currOff") (SliceSkip byteT "buf" (![uint64T] "bufOff"));;
          #()
        else #()))).

(* dir_fs.go *)

Definition dirFs := struct.decl [
  "fs" :: struct.t byteFs
].

Definition newDirFs: val :=
  rec: "newDirFs" "fs" :=
    struct.mk dirFs [
      "fs" ::= "fs"
    ].

Definition dirFs__Superblock: val :=
  rec: "dirFs__Superblock" "d" :=
    byteFs__Superblock (struct.loadF dirFs "fs" "d").

Definition dirFs__CreateDir: val :=
  rec: "dirFs__CreateDir" "d" :=
    let: ("i", "ok") := byteFs__AllocInode (struct.loadF dirFs "fs" "d") simplefs.DirType in
    (if: (~ "ok")
    then (#0, #false)
    else ("i", #true)).

Definition dirFs__CreateFile: val :=
  rec: "dirFs__CreateFile" "d" :=
    byteFs__AllocInode (struct.loadF dirFs "fs" "d") simplefs.FileType.

Definition dirFs__Remove: val :=
  rec: "dirFs__Remove" "d" "i" :=
    byteFs__FreeInode (struct.loadF dirFs "fs" "d") "i";;
    #().

Definition dirFs__GetInode: val :=
  rec: "dirFs__GetInode" "d" "i" :=
    byteFs__GetInode (struct.loadF dirFs "fs" "d") "i".

Definition dirFs__WriteInode: val :=
  rec: "dirFs__WriteInode" "d" "i" "inode" :=
    byteFs__WriteInode (struct.loadF dirFs "fs" "d") "i" "inode";;
    #().

Definition dirFs__GetDirectory: val :=
  rec: "dirFs__GetDirectory" "d" "i" :=
    let: "ino" := byteFs__GetInode (struct.loadF dirFs "fs" "d") "i" in
    (if: (inode.Inode__GetType "ino") ≠ simplefs.DirType
    then Panic "precondition violated"
    else #());;
    let: "buf" := NewSlice byteT (inode.Inode__GetLength "ino") in
    byteFs__Read (struct.loadF dirFs "fs" "d") "i" #0 "buf";;
    directory.DecodeDirectory "buf".

Definition dirFs__WriteDirectory: val :=
  rec: "dirFs__WriteDirectory" "d" "i" "dir" :=
    let: "buf" := directory.Directory__Encode "dir" in
    let: "in" := byteFs__GetInode (struct.loadF dirFs "fs" "d") "i" in
    inode.Inode__SetLength "in" (slice.len "buf");;
    byteFs__WriteInode (struct.loadF dirFs "fs" "d") "i" "in";;
    byteFs__Write (struct.loadF dirFs "fs" "d") "i" #0 "buf";;
    #().

Definition dirFs__Read: val :=
  rec: "dirFs__Read" "d" "i" "off" "buf" :=
    let: "in" := byteFs__GetInode (struct.loadF dirFs "fs" "d") "i" in
    (if: "off" ≥ (inode.Inode__GetLength "in")
    then #0
    else
      let: "bytesAvailable" := (inode.Inode__GetLength "in") - "off" in
      (if: (slice.len "buf") ≤ "bytesAvailable"
      then
        byteFs__Read (struct.loadF dirFs "fs" "d") "i" "off" "buf";;
        slice.len "buf"
      else
        byteFs__Read (struct.loadF dirFs "fs" "d") "i" "off" (SliceTake "buf" "bytesAvailable");;
        "bytesAvailable")).

Definition dirFs__Write: val :=
  rec: "dirFs__Write" "d" "i" "off" "buf" :=
    let: "in" := byteFs__GetInode (struct.loadF dirFs "fs" "d") "i" in
    (if: ("off" + (slice.len "buf")) > (inode.Inode__GetLength "in")
    then
      inode.Inode__SetLength "in" ("off" + (slice.len "buf"));;
      dirFs__WriteInode "d" "i" "in"
    else #());;
    byteFs__Write (struct.loadF dirFs "fs" "d") "i" "off" "buf";;
    #().

(* unix_fs.go *)

Definition Filesys := struct.decl [
  "fs" :: struct.t dirFs
].

Definition Error: ty := uint64T.

Definition ErrOk : expr := #0.

Definition ErrNoEnt : expr := #1.

Definition ErrExists : expr := #2.

Definition ErrNotDir : expr := #3.

Definition ErrIsDir : expr := #4.

Definition ErrNotEmpty : expr := #5.

Definition ErrNoSpace : expr := #6.

Definition ErrNameTooLong : expr := #7.

Definition Attr := struct.decl [
  "Ty" :: simplefs.InodeType;
  "Size" :: uint64T;
  "Mode" :: uint32T
].

Definition AttrFromInode: val :=
  rec: "AttrFromInode" "i" :=
    let: "meta" := inode.Inode__GetMeta "i" in
    struct.mk Attr [
      "Ty" ::= inode.Inode__GetType "i";
      "Size" ::= inode.Inode__GetLength "i";
      "Mode" ::= struct.get inode.Meta "Mode" "meta"
    ].

Definition Mkfs: val :=
  rec: "Mkfs" "d" "sz" :=
    mkBlockFs "d" "sz";;
    #().

Definition Load: val :=
  rec: "Load" "d" :=
    let: "fs" := newDirFs (newByteFs (struct.load blockFs (loadBlockFs "d"))) in
    struct.new Filesys [
      "fs" ::= "fs"
    ].

Definition Filesys__superblock: val :=
  rec: "Filesys__superblock" "f" :=
    dirFs__Superblock (struct.loadF Filesys "fs" "f").

Definition Filesys__getInode: val :=
  rec: "Filesys__getInode" "f" "i" :=
    (if: "i" ≥ (superblock.Superblock__NumInodes (Filesys__superblock "f"))
    then (slice.nil, ErrNoEnt)
    else
      let: "inode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "i" in
      (if: (~ (simplefs.InodeType__IsValid (inode.Inode__GetType "inode")))
      then (slice.nil, ErrNoEnt)
      else ("inode", ErrOk))).

Definition Filesys__getDirectory: val :=
  rec: "Filesys__getDirectory" "f" "i" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then (slice.nil, "err")
    else
      (if: (inode.Inode__GetType "ino") = simplefs.Invalid
      then (slice.nil, ErrNoEnt)
      else
        (if: (inode.Inode__GetType "ino") ≠ simplefs.DirType
        then (slice.nil, ErrNotDir)
        else
          let: "dir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "i" in
          ("dir", ErrOk)))).

Definition Filesys__createFile: val :=
  rec: "Filesys__createFile" "f" "mode" :=
    let: ("inodeNum", "ok") := dirFs__CreateFile (struct.loadF Filesys "fs" "f") in
    (if: (~ "ok")
    then
      (#0, struct.mk Attr [
       ], ErrNoSpace)
    else
      let: "ino" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "inodeNum" in
      let: "meta" := struct.mk inode.Meta [
        "Mode" ::= "mode"
      ] in
      inode.Inode__SetMeta "ino" "meta";;
      dirFs__WriteInode (struct.loadF Filesys "fs" "f") "inodeNum" "ino";;
      ("inodeNum", AttrFromInode "ino", ErrOk)).

Definition Filesys__createDirectory: val :=
  rec: "Filesys__createDirectory" "f" "mode" :=
    let: ("inodeNum", "ok") := dirFs__CreateDir (struct.loadF Filesys "fs" "f") in
    (if: (~ "ok")
    then
      (#0, struct.mk Attr [
       ], ErrNoSpace)
    else
      let: "ino" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "inodeNum" in
      let: "meta" := struct.mk inode.Meta [
        "Mode" ::= "mode"
      ] in
      inode.Inode__SetMeta "ino" "meta";;
      dirFs__WriteInode (struct.loadF Filesys "fs" "f") "inodeNum" "ino";;
      ("inodeNum", AttrFromInode "ino", ErrOk)).

Definition Filesys__link: val :=
  rec: "Filesys__link" "f" "parent" "name" "child" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: directory.Directory__Contains "dir" "name"
      then ErrExists
      else
        directory.Directory__Insert "dir" "name" "child";;
        dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
        ErrOk)).

Definition Filesys__removeFile: val :=
  rec: "Filesys__removeFile" "f" "i" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: (inode.Inode__GetType "ino") = simplefs.DirType
      then ErrIsDir
      else
        dirFs__Remove (struct.loadF Filesys "fs" "f") "i";;
        ErrOk)).

Definition Filesys__removeDir: val :=
  rec: "Filesys__removeDir" "f" "i" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "i" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: (~ (directory.Directory__IsEmpty "dir"))
      then ErrNotEmpty
      else
        dirFs__Remove (struct.loadF Filesys "fs" "f") "i";;
        ErrOk)).

Definition Filesys__Create: val :=
  rec: "Filesys__Create" "f" "parent" "name" "mode" :=
    (if: (StringLength "name") > directory.MAX_NAME_LEN
    then
      (#0, struct.mk Attr [
       ], ErrNameTooLong)
    else
      let: (("inodeNum", "attr"), "err") := Filesys__createFile "f" "mode" in
      (if: "err" ≠ ErrOk
      then
        (#0, struct.mk Attr [
         ], "err")
      else
        let: "err2" := Filesys__link "f" "parent" "name" "inodeNum" in
        (if: "err2" ≠ ErrOk
        then
          (#0, struct.mk Attr [
           ], "err2")
        else ("inodeNum", "attr", ErrOk)))).

Definition Filesys__Lookup: val :=
  rec: "Filesys__Lookup" "f" "parent" "name" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then
      (#0, struct.mk Attr [
       ], "err")
    else
      let: ("childInum", "ok") := directory.Directory__Lookup "dir" "name" in
      (if: (~ "ok")
      then
        (#0, struct.mk Attr [
         ], ErrNoEnt)
      else
        let: "inode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "childInum" in
        ("childInum", AttrFromInode "inode", ErrOk))).

Definition Filesys__Unlink: val :=
  rec: "Filesys__Unlink" "f" "parent" "name" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      let: ("childInum", "ok") := directory.Directory__Lookup "dir" "name" in
      (if: (~ "ok")
      then ErrNoEnt
      else
        let: "err2" := Filesys__removeFile "f" "childInum" in
        (if: "err2" ≠ ErrOk
        then "err2"
        else
          directory.Directory__Remove "dir" "name";;
          dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
          ErrOk))).

Definition Filesys__Rmdir: val :=
  rec: "Filesys__Rmdir" "f" "parent" "name" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      let: ("childInum", "ok") := directory.Directory__Lookup "dir" "name" in
      (if: (~ "ok")
      then ErrNoEnt
      else
        let: "err2" := Filesys__removeDir "f" "childInum" in
        (if: "err2" ≠ ErrOk
        then "err2"
        else
          directory.Directory__Remove "dir" "name";;
          dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
          ErrOk))).

Definition Filesys__Read: val :=
  rec: "Filesys__Read" "f" "i" "off" "buf" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then (#0, "err")
    else
      (if: (inode.Inode__GetType "ino") = simplefs.DirType
      then (#0, ErrIsDir)
      else
        let: "n" := dirFs__Read (struct.loadF Filesys "fs" "f") "i" "off" "buf" in
        ("n", ErrOk))).

Definition Filesys__Write: val :=
  rec: "Filesys__Write" "f" "i" "off" "buf" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: (inode.Inode__GetType "ino") = simplefs.DirType
      then ErrIsDir
      else
        dirFs__Write (struct.loadF Filesys "fs" "f") "i" "off" "buf";;
        ErrOk)).

Definition Filesys__Getattr: val :=
  rec: "Filesys__Getattr" "f" "i" :=
    let: ("inode", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then
      (struct.mk Attr [
       ], "err")
    else (AttrFromInode "inode", ErrOk)).

Definition Filesys__Setattr: val :=
  rec: "Filesys__Setattr" "f" "i" "mode" :=
    let: ("inode", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then
      (struct.mk Attr [
       ], "err")
    else
      (if: "mode" ≠ #null
      then inode.Inode__SetMode "inode" (![uint32T] "mode")
      else #());;
      dirFs__WriteInode (struct.loadF Filesys "fs" "f") "i" "inode";;
      (AttrFromInode "inode", ErrOk)).

Definition Filesys__Mkdir: val :=
  rec: "Filesys__Mkdir" "f" "parent" "mode" "name" :=
    (if: (StringLength "name") > directory.MAX_NAME_LEN
    then
      (#0, struct.mk Attr [
       ], ErrNameTooLong)
    else
      let: (("inodeNum", "attr"), "err") := Filesys__createDirectory "f" "mode" in
      (if: "err" ≠ ErrOk
      then
        (#0, struct.mk Attr [
         ], "err")
      else
        let: "err2" := Filesys__link "f" "parent" "name" "inodeNum" in
        (if: "err2" ≠ ErrOk
        then
          (#0, struct.mk Attr [
           ], "err2")
        else ("inodeNum", "attr", ErrOk)))).

Definition Filesys__Readdir: val :=
  rec: "Filesys__Readdir" "f" "i" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "i" in
    (if: "err" ≠ ErrOk
    then (slice.nil, "err")
    else
      let: "dents" := SliceAppendSlice (struct.t directory.DirEnt) (NewSlice (struct.t directory.DirEnt) #0) (struct.loadF directory.Directory "Dents" "dir") in
      ("dents", ErrOk)).

Definition Filesys__renameRemoveDst: val :=
  rec: "Filesys__renameRemoveDst" "f" "srcInum" "newDir" "dstName" :=
    let: ("dstInum", "ok") := directory.Directory__Lookup "newDir" "dstName" in
    (if: (~ "ok")
    then ErrOk
    else
      let: "srcInode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "srcInum" in
      let: "dstInode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "dstInum" in
      (if: (~ (simplefs.InodeType__IsValid (inode.Inode__GetType "dstInode")))
      then ErrOk
      else
        (if: ((inode.Inode__GetType "srcInode") = simplefs.FileType) && ((inode.Inode__GetType "dstInode") = simplefs.FileType)
        then
          let: "err" := Filesys__removeFile "f" "dstInum" in
          "err"
        else
          (if: ((inode.Inode__GetType "srcInode") = simplefs.DirType) && ((inode.Inode__GetType "dstInode") = simplefs.DirType)
          then
            let: "err" := Filesys__removeDir "f" "dstInum" in
            "err"
          else ErrExists)))).

Definition Filesys__renameSameDir: val :=
  rec: "Filesys__renameSameDir" "f" "parent" "oldName" "newName" :=
    let: "dir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "parent" in
    let: ("childInum", "ok") := directory.Directory__Lookup "dir" "oldName" in
    (if: (~ "ok")
    then ErrNoEnt
    else
      directory.Directory__Remove "dir" "oldName";;
      let: "err" := Filesys__renameRemoveDst "f" "childInum" "dir" "newName" in
      (if: "err" ≠ ErrOk
      then "err"
      else
        directory.Directory__Insert "dir" "newName" "childInum";;
        dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
        ErrOk)).

Definition Filesys__Rename: val :=
  rec: "Filesys__Rename" "f" "oldParent" "oldName" "newParent" "newName" :=
    (if: (StringLength "newName") > directory.MAX_NAME_LEN
    then ErrNameTooLong
    else
      (if: "oldParent" = "newParent"
      then Filesys__renameSameDir "f" "oldParent" "oldName" "newName"
      else
        let: "oldDir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "oldParent" in
        let: ("childInum", "ok") := directory.Directory__Lookup "oldDir" "oldName" in
        (if: (~ "ok")
        then ErrNoEnt
        else
          let: "newDir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "newParent" in
          directory.Directory__Remove "oldDir" "oldName";;
          let: "err" := Filesys__renameRemoveDst "f" "childInum" "newDir" "newName" in
          (if: "err" ≠ ErrOk
          then "err"
          else
            directory.Directory__Insert "newDir" "newName" "childInum";;
            dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "oldParent" "oldDir";;
            dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "newParent" "newDir";;
            ErrOk)))).
