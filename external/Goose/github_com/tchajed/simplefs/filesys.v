(* autogenerated from github.com/tchajed/simplefs/filesys *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.tchajed.simplefs.
From Goose Require github_com.tchajed.simplefs.alloc.
From Goose Require github_com.tchajed.simplefs.directory.
From Goose Require github_com.tchajed.simplefs.inode.
From Goose Require github_com.tchajed.simplefs.superblock.

From Perennial.goose_lang Require Import ffi.disk_prelude.

(* block_fs.go *)

Definition blockFs := struct.decl [
  "sb" :: ptrT;
  "d" :: disk.Disk;
  "ba" :: ptrT;
  "ia" :: ptrT
].

(* Zero the relevant parts of the disk and write the superblock. *)
Definition zeroDisk: val :=
  rec: "zeroDisk" "d" "sz" :=
    let: "sb" := superblock.InitSuperblock "sz" in
    disk.Write #0 (superblock.Superblock__Encode "sb");;
    let: "zero_blk" := NewSlice byteT disk.BlockSize in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (struct.loadF superblock.Superblock "InodeBlocks" "sb")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      disk.Write ((superblock.Superblock__InodeStart "sb") + (![uint64T] "i")) "zero_blk";;
      Continue);;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (struct.loadF superblock.Superblock "DataBitmapBlocks" "sb")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      disk.Write ((superblock.Superblock__DataBitmapStart "sb") + (![uint64T] "i")) "zero_blk";;
      Continue);;
    "sb".

Definition mkBlockFs: val :=
  rec: "mkBlockFs" "d" "sz" :=
    let: "sb" := zeroDisk "d" "sz" in
    let: "root_inode" := inode.NewInode simplefs.DirType in
    inode.Inode__SetMeta "root_inode" (struct.mk inode.Meta [
      "Mode" ::= #(U32 493)
    ]);;
    inode.Inode__Write "root_inode" "d" "sb" simplefs.ROOT_INUM;;
    #().

Definition loadBlockFs: val :=
  rec: "loadBlockFs" "d" :=
    let: "sb" := superblock.LoadSuperblock "d" in
    let: "ba" := alloc.NewBlockAllocator "d" "sb" in
    let: "ia" := alloc.NewInodeAllocator "d" "sb" in
    struct.new blockFs [
      "sb" ::= "sb";
      "d" ::= "d";
      "ba" ::= "ba";
      "ia" ::= "ia"
    ].

Definition blockFs__Superblock: val :=
  rec: "blockFs__Superblock" "fs" :=
    struct.loadF blockFs "sb" "fs".

(* AllocInode allocates a new inode of the given type and meta. Its length and
   block pointers are all guaranteed to be zeroed. *)
Definition blockFs__AllocInode: val :=
  rec: "blockFs__AllocInode" "fs" "ty" "meta" :=
    let: ("inum", "ok") := alloc.InodeAllocator__Alloc (struct.loadF blockFs "ia" "fs") "ty" in
    (if: (~ "ok")
    then (#0, #false)
    else
      let: "ino" := inode.ReadInode (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "inum" in
      inode.Inode__SetMeta "ino" "meta";;
      inode.Inode__Write "ino" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "inum";;
      ("inum", #true)).

Definition blockFs__FreeInode: val :=
  rec: "blockFs__FreeInode" "fs" "i" :=
    alloc.InodeAllocator__Free (struct.loadF blockFs "ia" "fs") "i";;
    let: "ino" := inode.ReadInode (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < inode.NUM_BLOCK_PTRS); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "b" := inode.Inode__GetBlockPtr "ino" (![uint64T] "i") in
      (if: "b" ≠ #(U32 0)
      then
        alloc.BlockAllocator__Free (struct.loadF blockFs "ba" "fs") "b";;
        Continue
      else Continue));;
    let: "zero_inode" := inode.NewInode simplefs.Invalid in
    inode.Inode__Write "zero_inode" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i";;
    #().

(* GetInode reads the given inode. Only intended to expose the inode length and
   meta - type and block pointers are handled by `blockFs`. *)
Definition blockFs__GetInode: val :=
  rec: "blockFs__GetInode" "fs" "i" :=
    inode.ReadInode (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i".

(* Change the meta of an inode. *)
Definition blockFs__SetMeta: val :=
  rec: "blockFs__SetMeta" "fs" "i" "meta" :=
    let: "ino" := blockFs__GetInode "fs" "i" in
    inode.Inode__SetMeta "ino" "meta";;
    inode.Inode__Write "ino" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i";;
    #().

(* Change the length of an inode. *)
Definition blockFs__SetLength: val :=
  rec: "blockFs__SetLength" "fs" "i" "length" :=
    let: "ino" := blockFs__GetInode "fs" "i" in
    inode.Inode__SetLength "ino" "length";;
    inode.Inode__Write "ino" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i";;
    #().

Definition blockFs__getBlockNum: val :=
  rec: "blockFs__getBlockNum" "fs" "ino" "off" :=
    inode.Inode__GetBlockPtr "ino" "off".

Definition blockFs__ReadBlock: val :=
  rec: "blockFs__ReadBlock" "fs" "i" "off" :=
    (if: "off" ≥ inode.NUM_DIRECT
    then NewSlice byteT disk.BlockSize
    else
      let: "ino" := blockFs__GetInode "fs" "i" in
      let: "blkPtr" := blockFs__getBlockNum "fs" "ino" "off" in
      (if: "blkPtr" = #(U32 0)
      then NewSlice byteT disk.BlockSize
      else disk.Read ((superblock.Superblock__DataStart (struct.loadF blockFs "sb" "fs")) + (to_u64 "blkPtr")))).

Definition blockFs__allocBlockNum: val :=
  rec: "blockFs__allocBlockNum" "fs" "i" "ino" "off" :=
    let: "blkPtr" := blockFs__getBlockNum "fs" "ino" "off" in
    (if: "blkPtr" ≠ #(U32 0)
    then ("blkPtr", #true)
    else
      let: ("blkPtr2", "ok") := alloc.BlockAllocator__Alloc (struct.loadF blockFs "ba" "fs") in
      (if: (~ "ok")
      then (#(U32 0), #false)
      else
        inode.Inode__SetBlockPtr "ino" "off" "blkPtr2";;
        inode.Inode__Write "ino" (struct.loadF blockFs "d" "fs") (struct.loadF blockFs "sb" "fs") "i";;
        ("blkPtr2", #true))).

Definition blockFs__WriteBlock: val :=
  rec: "blockFs__WriteBlock" "fs" "i" "off" "b" :=
    (if: "off" ≥ inode.NUM_DIRECT
    then #false
    else
      let: "ino" := blockFs__GetInode "fs" "i" in
      let: ("blkPtr", "ok") := blockFs__allocBlockNum "fs" "i" "ino" "off" in
      (if: (~ "ok")
      then #false
      else
        disk.Write ((superblock.Superblock__DataStart (struct.loadF blockFs "sb" "fs")) + (to_u64 "blkPtr")) "b";;
        #true)).

(* byte_fs.go *)

Definition byteFs := struct.decl [
  "fs" :: struct.t blockFs
].

Definition newByteFs: val :=
  rec: "newByteFs" "fs" :=
    struct.mk byteFs [
      "fs" ::= "fs"
    ].

Definition byteFs__Superblock: val :=
  rec: "byteFs__Superblock" "b" :=
    blockFs__Superblock (struct.loadF byteFs "fs" "b").

Definition byteFs__GetInode: val :=
  rec: "byteFs__GetInode" "b" "inum" :=
    blockFs__GetInode (struct.loadF byteFs "fs" "b") "inum".

(* Change the meta of an inode. *)
Definition byteFs__SetMeta: val :=
  rec: "byteFs__SetMeta" "fs" "inum" "meta" :=
    blockFs__SetMeta (struct.loadF byteFs "fs" "fs") "inum" "meta";;
    #().

(* Change the length of an inode. *)
Definition byteFs__SetLength: val :=
  rec: "byteFs__SetLength" "fs" "inum" "length" :=
    blockFs__SetLength (struct.loadF byteFs "fs" "fs") "inum" "length";;
    #().

Definition byteFs__AllocInode: val :=
  rec: "byteFs__AllocInode" "b" "ty" "meta" :=
    blockFs__AllocInode (struct.loadF byteFs "fs" "b") "ty" "meta".

Definition byteFs__FreeInode: val :=
  rec: "byteFs__FreeInode" "b" "i" :=
    blockFs__FreeInode (struct.loadF byteFs "fs" "b") "i";;
    #().

Definition byteFs__readWithinBlock: val :=
  rec: "byteFs__readWithinBlock" "b" "i" "off" "buf" :=
    (if: (~ ((#0 < (slice.len "buf")) && ((slice.len "buf") ≤ (disk.BlockSize - ("off" `rem` disk.BlockSize)))))
    then Panic "readWithinBlock precondition violated: read must be in one block"
    else #());;
    (if: (("off" `rem` disk.BlockSize) = #0) && ((slice.len "buf") = disk.BlockSize)
    then
      let: "blkRead" := blockFs__ReadBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) in
      SliceCopy byteT "buf" "blkRead";;
      #()
    else
      let: "blkRead" := blockFs__ReadBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) in
      SliceCopy byteT "buf" (SliceSubslice byteT "blkRead" ("off" `rem` disk.BlockSize) (("off" `rem` disk.BlockSize) + (slice.len "buf")));;
      #()).

(* readTillAligned reads from inode i starting at currOff, up to a block
   boundary (or less if fewer bytes are requested), filling buf and returning
   the number of bytes read *)
Definition byteFs__readTillAligned: val :=
  rec: "byteFs__readTillAligned" "b" "i" "currOff" "buf" :=
    control.impl.Assert (("currOff" `rem` disk.BlockSize) ≠ #0);;
    let: "toRead" := disk.BlockSize - ("currOff" `rem` disk.BlockSize) in
    (if: (slice.len "buf") < "toRead"
    then
      byteFs__readWithinBlock "b" "i" "currOff" "buf";;
      slice.len "buf"
    else
      byteFs__readWithinBlock "b" "i" "currOff" (SliceTake "buf" "toRead");;
      "toRead").

Definition byteFs__Read: val :=
  rec: "byteFs__Read" "b" "i" "off" "buf" :=
    let: "currOff" := ref_to uint64T "off" in
    let: "bufOff" := ref_to uint64T #0 in
    let: "remaining" := ref_to uint64T (slice.len "buf") in
    (if: (![uint64T] "remaining") = #0
    then #()
    else
      (if: ((![uint64T] "currOff") `rem` disk.BlockSize) ≠ #0
      then
        let: "n" := byteFs__readTillAligned "b" "i" (![uint64T] "currOff") "buf" in
        "currOff" <-[uint64T] ((![uint64T] "currOff") + "n");;
        "bufOff" <-[uint64T] ((![uint64T] "bufOff") + "n");;
        "remaining" <-[uint64T] ((![uint64T] "remaining") - "n")
      else #());;
      (if: (![uint64T] "remaining") = #0
      then #()
      else
        control.impl.Assert (((![uint64T] "currOff") `rem` disk.BlockSize) = #0);;
        Skip;;
        (for: (λ: <>, (![uint64T] "remaining") ≥ disk.BlockSize); (λ: <>, Skip) := λ: <>,
          byteFs__readWithinBlock "b" "i" (![uint64T] "currOff") (SliceSubslice byteT "buf" (![uint64T] "bufOff") ((![uint64T] "bufOff") + disk.BlockSize));;
          "currOff" <-[uint64T] ((![uint64T] "currOff") + disk.BlockSize);;
          "bufOff" <-[uint64T] ((![uint64T] "bufOff") + disk.BlockSize);;
          "remaining" <-[uint64T] ((![uint64T] "remaining") - disk.BlockSize);;
          Continue);;
        (if: ((![uint64T] "remaining") < disk.BlockSize) && ((![uint64T] "remaining") > #0)
        then
          byteFs__readWithinBlock "b" "i" (![uint64T] "currOff") (SliceSkip byteT "buf" (![uint64T] "bufOff"));;
          #()
        else #()))).

(* writeWithinBlock writes buf to off. It handles all cases where the whole
   write fits in one block, including a prefix, a suffix, and writing the whole
   block. *)
Definition byteFs__writeWithinBlock: val :=
  rec: "byteFs__writeWithinBlock" "b" "i" "off" "buf" :=
    let: "n" := slice.len "buf" in
    (if: "n" = #0
    then #true
    else
      (if: (~ ("n" ≤ (disk.BlockSize - ("off" `rem` disk.BlockSize))))
      then Panic "writeWithinBlock precondition violated: write must be in one block"
      else #());;
      (if: (("off" `rem` disk.BlockSize) = #0) && ("n" = disk.BlockSize)
      then
        let: "ok" := blockFs__WriteBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) "buf" in
        "ok"
      else
        let: "blk" := blockFs__ReadBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) in
        SliceCopy byteT (SliceSubslice byteT "blk" ("off" `rem` disk.BlockSize) (("off" `rem` disk.BlockSize) + "n")) "buf";;
        let: "ok" := blockFs__WriteBlock (struct.loadF byteFs "fs" "b") "i" ("off" `quot` disk.BlockSize) "blk" in
        "ok")).

(* writeAlignedBlocks writes buf to off. It requires off to be block aligned and
   len(buf) to be a multiple of the block size. *)
Definition byteFs__writeAlignedBlocks: val :=
  rec: "byteFs__writeAlignedBlocks" "b" "inum" "off" "buf" :=
    (if: (slice.len "buf") = #0
    then #true
    else
      control.impl.Assert ((("off" `rem` disk.BlockSize) = #0) && (((slice.len "buf") `rem` disk.BlockSize) = #0));;
      let: "num_blocks" := (slice.len "buf") `quot` disk.BlockSize in
      let: "ok" := ref_to boolT #true in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "num_blocks"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: "bufOff" := (![uint64T] "i") * disk.BlockSize in
        "ok" <-[boolT] (byteFs__writeWithinBlock "b" "inum" ("off" + "bufOff") (SliceSubslice byteT "buf" "bufOff" ("bufOff" + disk.BlockSize)));;
        (if: (~ (![boolT] "ok"))
        then Break
        else Continue));;
      ![boolT] "ok").

(* writeParts breaks down a long write into block-sized pieces.

   prefix is written to the end of the first block, then blocks, then suffix is
   written to the end of the last block. Any part might be empty. The `blocks`
   part is guaranteed to be a multiple of the block size and start at a
   block-aligned offset (note: if its length is zero it may not start at a block
   boundary). *)
Definition writeParts := struct.decl [
  "off" :: uint64T;
  "prefix" :: slice.T byteT;
  "blocks" :: slice.T byteT;
  "suffix" :: slice.T byteT
].

Definition writeParts__blocksOff: val :=
  rec: "writeParts__blocksOff" "wp" :=
    (struct.get writeParts "off" "wp") + (slice.len (struct.get writeParts "prefix" "wp")).

Definition writeParts__suffixOff: val :=
  rec: "writeParts__suffixOff" "wp" :=
    ((struct.get writeParts "off" "wp") + (slice.len (struct.get writeParts "prefix" "wp"))) + (slice.len (struct.get writeParts "blocks" "wp")).

Definition writeParts__wf: val :=
  rec: "writeParts__wf" "wp" :=
    (((((slice.len (struct.get writeParts "prefix" "wp")) ≤ (disk.BlockSize - ((struct.get writeParts "off" "wp") `rem` disk.BlockSize))) && (((slice.len (struct.get writeParts "blocks" "wp")) = #0) || (((writeParts__blocksOff "wp") `rem` disk.BlockSize) = #0))) && (((slice.len (struct.get writeParts "blocks" "wp")) `rem` disk.BlockSize) = #0)) && (((slice.len (struct.get writeParts "suffix" "wp")) = #0) || (((writeParts__suffixOff "wp") `rem` disk.BlockSize) = #0))) && ((slice.len (struct.get writeParts "suffix" "wp")) ≤ disk.BlockSize).

Definition newWriteParts: val :=
  rec: "newWriteParts" "off" "buf" :=
    let: "w" := struct.new writeParts [
      "off" ::= "off"
    ] in
    let: "buf2" := ref_to (slice.T byteT) "buf" in
    (if: ("off" `rem` disk.BlockSize) ≠ #0
    then
      let: "toWrite" := disk.BlockSize - ("off" `rem` disk.BlockSize) in
      (if: (slice.len "buf") ≤ "toWrite"
      then
        struct.storeF writeParts "prefix" "w" "buf";;
        "buf2" <-[slice.T byteT] slice.nil
      else
        let: ("0_ret", "1_ret") := std.SliceSplit byteT "buf" "toWrite" in
        struct.storeF writeParts "prefix" "w" "0_ret";;
        "buf2" <-[slice.T byteT] "1_ret")
    else #());;
    let: "blocksLen" := ((slice.len (![slice.T byteT] "buf2")) `quot` disk.BlockSize) * disk.BlockSize in
    let: ("0_ret", "1_ret") := std.SliceSplit byteT (![slice.T byteT] "buf2") "blocksLen" in
    struct.storeF writeParts "blocks" "w" "0_ret";;
    struct.storeF writeParts "suffix" "w" "1_ret";;
    control.impl.Assert (writeParts__wf "w");;
    struct.load writeParts "w".

Definition byteFs__doWrite: val :=
  rec: "byteFs__doWrite" "b" "i" "w" :=
    (if: (~ (byteFs__writeWithinBlock "b" "i" (struct.get writeParts "off" "w") (struct.get writeParts "prefix" "w")))
    then #false
    else
      (if: (~ (byteFs__writeAlignedBlocks "b" "i" (writeParts__blocksOff "w") (struct.get writeParts "blocks" "w")))
      then #false
      else byteFs__writeWithinBlock "b" "i" (writeParts__suffixOff "w") (struct.get writeParts "suffix" "w"))).

(* Write stores buf into inode i's data at offset off *)
Definition byteFs__Write: val :=
  rec: "byteFs__Write" "b" "i" "off" "buf" :=
    (if: ("off" + (slice.len "buf")) > (inode.NUM_DIRECT * #4096)
    then #false
    else
      let: "wp" := newWriteParts "off" "buf" in
      byteFs__doWrite "b" "i" "wp").

(* dir_fs.go *)

Definition dirFs := struct.decl [
  "fs" :: struct.t byteFs
].

Definition newDirFs: val :=
  rec: "newDirFs" "fs" :=
    struct.mk dirFs [
      "fs" ::= "fs"
    ].

Definition dirFs__Superblock: val :=
  rec: "dirFs__Superblock" "d" :=
    byteFs__Superblock (struct.loadF dirFs "fs" "d").

Definition dirFs__GetInode: val :=
  rec: "dirFs__GetInode" "d" "inum" :=
    byteFs__GetInode (struct.loadF dirFs "fs" "d") "inum".

Definition dirFs__SetMeta: val :=
  rec: "dirFs__SetMeta" "d" "inum" "meta" :=
    byteFs__SetMeta (struct.loadF dirFs "fs" "d") "inum" "meta";;
    #().

Definition dirFs__CreateDir: val :=
  rec: "dirFs__CreateDir" "d" "meta" :=
    let: ("i", "ok") := byteFs__AllocInode (struct.loadF dirFs "fs" "d") simplefs.DirType "meta" in
    (if: (~ "ok")
    then (#0, #false)
    else ("i", #true)).

Definition dirFs__CreateFile: val :=
  rec: "dirFs__CreateFile" "d" "meta" :=
    byteFs__AllocInode (struct.loadF dirFs "fs" "d") simplefs.FileType "meta".

Definition dirFs__Remove: val :=
  rec: "dirFs__Remove" "d" "i" :=
    byteFs__FreeInode (struct.loadF dirFs "fs" "d") "i";;
    #().

Definition dirFs__GetDirectory: val :=
  rec: "dirFs__GetDirectory" "d" "i" :=
    let: "ino" := byteFs__GetInode (struct.loadF dirFs "fs" "d") "i" in
    (if: (inode.Inode__GetType "ino") ≠ simplefs.DirType
    then Panic "precondition violated"
    else #());;
    let: "buf" := NewSlice byteT (inode.Inode__GetLength "ino") in
    byteFs__Read (struct.loadF dirFs "fs" "d") "i" #0 "buf";;
    directory.DecodeDirectory "buf".

Definition dirFs__WriteDirectory: val :=
  rec: "dirFs__WriteDirectory" "d" "i" "dir" :=
    let: "buf" := directory.Directory__Encode "dir" in
    byteFs__SetLength (struct.loadF dirFs "fs" "d") "i" (slice.len "buf");;
    byteFs__Write (struct.loadF dirFs "fs" "d") "i" #0 "buf";;
    #().

Definition dirFs__Read: val :=
  rec: "dirFs__Read" "d" "i" "off" "buf" :=
    let: "in" := byteFs__GetInode (struct.loadF dirFs "fs" "d") "i" in
    (if: "off" ≥ (inode.Inode__GetLength "in")
    then #0
    else
      let: "bytesAvailable" := (inode.Inode__GetLength "in") - "off" in
      (if: (slice.len "buf") ≤ "bytesAvailable"
      then
        byteFs__Read (struct.loadF dirFs "fs" "d") "i" "off" "buf";;
        slice.len "buf"
      else
        byteFs__Read (struct.loadF dirFs "fs" "d") "i" "off" (SliceTake "buf" "bytesAvailable");;
        "bytesAvailable")).

Definition dirFs__Write: val :=
  rec: "dirFs__Write" "d" "i" "off" "buf" :=
    let: "ino" := byteFs__GetInode (struct.loadF dirFs "fs" "d") "i" in
    (if: ("off" + (slice.len "buf")) > (inode.Inode__GetLength "ino")
    then byteFs__SetLength (struct.loadF dirFs "fs" "d") "i" ("off" + (slice.len "buf"))
    else #());;
    byteFs__Write (struct.loadF dirFs "fs" "d") "i" "off" "buf";;
    #().

(* unix_fs.go *)

Definition Filesys := struct.decl [
  "fs" :: struct.t dirFs
].

Definition Error: ty := uint64T.

Definition ErrOk : expr := #0.

Definition ErrNoEnt : expr := #1.

Definition ErrExists : expr := #2.

Definition ErrNotDir : expr := #3.

Definition ErrIsDir : expr := #4.

Definition ErrNotEmpty : expr := #5.

Definition ErrNoSpace : expr := #6.

Definition ErrNameTooLong : expr := #7.

Definition Attr := struct.decl [
  "Ty" :: simplefs.InodeType;
  "Size" :: uint64T;
  "Mode" :: uint32T
].

Definition AttrFromInode: val :=
  rec: "AttrFromInode" "i" :=
    let: "meta" := inode.Inode__GetMeta "i" in
    struct.mk Attr [
      "Ty" ::= inode.Inode__GetType "i";
      "Size" ::= inode.Inode__GetLength "i";
      "Mode" ::= struct.get inode.Meta "Mode" "meta"
    ].

Definition Mkfs: val :=
  rec: "Mkfs" "d" "sz" :=
    mkBlockFs "d" "sz";;
    #().

Definition Load: val :=
  rec: "Load" "d" :=
    let: "fs" := newDirFs (newByteFs (struct.load blockFs (loadBlockFs "d"))) in
    struct.new Filesys [
      "fs" ::= "fs"
    ].

Definition Filesys__superblock: val :=
  rec: "Filesys__superblock" "f" :=
    dirFs__Superblock (struct.loadF Filesys "fs" "f").

Definition Filesys__getInode: val :=
  rec: "Filesys__getInode" "f" "i" :=
    (if: "i" ≥ (superblock.Superblock__NumInodes (Filesys__superblock "f"))
    then (slice.nil, ErrNoEnt)
    else
      let: "inode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "i" in
      (if: (~ (simplefs.InodeType__IsValid (inode.Inode__GetType "inode")))
      then (slice.nil, ErrNoEnt)
      else ("inode", ErrOk))).

Definition Filesys__getDirectory: val :=
  rec: "Filesys__getDirectory" "f" "i" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then (slice.nil, "err")
    else
      (if: (inode.Inode__GetType "ino") = simplefs.Invalid
      then (slice.nil, ErrNoEnt)
      else
        (if: (inode.Inode__GetType "ino") ≠ simplefs.DirType
        then (slice.nil, ErrNotDir)
        else
          let: "dir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "i" in
          ("dir", ErrOk)))).

Definition Filesys__createFile: val :=
  rec: "Filesys__createFile" "f" "mode" :=
    let: ("inodeNum", "ok") := dirFs__CreateFile (struct.loadF Filesys "fs" "f") (struct.mk inode.Meta [
      "Mode" ::= "mode"
    ]) in
    (if: (~ "ok")
    then
      (#0, struct.mk Attr [
       ], ErrNoSpace)
    else
      ("inodeNum", struct.mk Attr [
         "Ty" ::= simplefs.FileType;
         "Size" ::= #0;
         "Mode" ::= "mode"
       ], ErrOk)).

Definition Filesys__createDirectory: val :=
  rec: "Filesys__createDirectory" "f" "mode" :=
    let: ("inodeNum", "ok") := dirFs__CreateDir (struct.loadF Filesys "fs" "f") (struct.mk inode.Meta [
      "Mode" ::= "mode"
    ]) in
    (if: (~ "ok")
    then
      (#0, struct.mk Attr [
       ], ErrNoSpace)
    else
      ("inodeNum", struct.mk Attr [
         "Ty" ::= simplefs.DirType;
         "Size" ::= #0;
         "Mode" ::= "mode"
       ], ErrOk)).

Definition Filesys__link: val :=
  rec: "Filesys__link" "f" "parent" "name" "child" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: directory.Directory__Contains "dir" "name"
      then ErrExists
      else
        directory.Directory__Insert "dir" "name" "child";;
        dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
        ErrOk)).

Definition Filesys__removeFile: val :=
  rec: "Filesys__removeFile" "f" "i" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: (inode.Inode__GetType "ino") = simplefs.DirType
      then ErrIsDir
      else
        dirFs__Remove (struct.loadF Filesys "fs" "f") "i";;
        ErrOk)).

Definition Filesys__removeDir: val :=
  rec: "Filesys__removeDir" "f" "i" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "i" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: (~ (directory.Directory__IsEmpty "dir"))
      then ErrNotEmpty
      else
        dirFs__Remove (struct.loadF Filesys "fs" "f") "i";;
        ErrOk)).

Definition Filesys__Create: val :=
  rec: "Filesys__Create" "f" "parent" "name" "mode" :=
    (if: (StringLength "name") > directory.MAX_NAME_LEN
    then
      (#0, struct.mk Attr [
       ], ErrNameTooLong)
    else
      let: (("inodeNum", "attr"), "err") := Filesys__createFile "f" "mode" in
      (if: "err" ≠ ErrOk
      then
        (#0, struct.mk Attr [
         ], "err")
      else
        let: "err2" := Filesys__link "f" "parent" "name" "inodeNum" in
        (if: "err2" ≠ ErrOk
        then
          (#0, struct.mk Attr [
           ], "err2")
        else ("inodeNum", "attr", ErrOk)))).

Definition Filesys__Lookup: val :=
  rec: "Filesys__Lookup" "f" "parent" "name" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then
      (#0, struct.mk Attr [
       ], "err")
    else
      let: ("childInum", "ok") := directory.Directory__Lookup "dir" "name" in
      (if: (~ "ok")
      then
        (#0, struct.mk Attr [
         ], ErrNoEnt)
      else
        let: "inode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "childInum" in
        ("childInum", AttrFromInode "inode", ErrOk))).

Definition Filesys__Unlink: val :=
  rec: "Filesys__Unlink" "f" "parent" "name" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      let: ("childInum", "ok") := directory.Directory__Lookup "dir" "name" in
      (if: (~ "ok")
      then ErrNoEnt
      else
        let: "err2" := Filesys__removeFile "f" "childInum" in
        (if: "err2" ≠ ErrOk
        then "err2"
        else
          directory.Directory__Remove "dir" "name";;
          dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
          ErrOk))).

Definition Filesys__Rmdir: val :=
  rec: "Filesys__Rmdir" "f" "parent" "name" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "parent" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      let: ("childInum", "ok") := directory.Directory__Lookup "dir" "name" in
      (if: (~ "ok")
      then ErrNoEnt
      else
        let: "err2" := Filesys__removeDir "f" "childInum" in
        (if: "err2" ≠ ErrOk
        then "err2"
        else
          directory.Directory__Remove "dir" "name";;
          dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
          ErrOk))).

Definition Filesys__Read: val :=
  rec: "Filesys__Read" "f" "i" "off" "buf" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then (#0, "err")
    else
      (if: (inode.Inode__GetType "ino") = simplefs.DirType
      then (#0, ErrIsDir)
      else
        let: "n" := dirFs__Read (struct.loadF Filesys "fs" "f") "i" "off" "buf" in
        ("n", ErrOk))).

Definition Filesys__Write: val :=
  rec: "Filesys__Write" "f" "i" "off" "buf" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then "err"
    else
      (if: (inode.Inode__GetType "ino") = simplefs.DirType
      then ErrIsDir
      else
        dirFs__Write (struct.loadF Filesys "fs" "f") "i" "off" "buf";;
        ErrOk)).

Definition Filesys__Getattr: val :=
  rec: "Filesys__Getattr" "f" "i" :=
    let: ("inode", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then
      (struct.mk Attr [
       ], "err")
    else (AttrFromInode "inode", ErrOk)).

Definition Filesys__Setattr: val :=
  rec: "Filesys__Setattr" "f" "i" "mode" :=
    let: ("ino", "err") := Filesys__getInode "f" "i" in
    (if: "err" ≠ ErrOk
    then
      (struct.mk Attr [
       ], "err")
    else
      (if: "mode" ≠ #null
      then
        dirFs__SetMeta (struct.loadF Filesys "fs" "f") "i" (struct.mk inode.Meta [
          "Mode" ::= ![uint32T] "mode"
        ])
      else #());;
      (AttrFromInode "ino", ErrOk)).

Definition Filesys__Mkdir: val :=
  rec: "Filesys__Mkdir" "f" "parent" "mode" "name" :=
    (if: (StringLength "name") > directory.MAX_NAME_LEN
    then
      (#0, struct.mk Attr [
       ], ErrNameTooLong)
    else
      let: (("inodeNum", "attr"), "err") := Filesys__createDirectory "f" "mode" in
      (if: "err" ≠ ErrOk
      then
        (#0, struct.mk Attr [
         ], "err")
      else
        let: "err2" := Filesys__link "f" "parent" "name" "inodeNum" in
        (if: "err2" ≠ ErrOk
        then
          (#0, struct.mk Attr [
           ], "err2")
        else ("inodeNum", "attr", ErrOk)))).

Definition Filesys__Readdir: val :=
  rec: "Filesys__Readdir" "f" "i" :=
    let: ("dir", "err") := Filesys__getDirectory "f" "i" in
    (if: "err" ≠ ErrOk
    then (slice.nil, "err")
    else
      let: "dents" := SliceAppendSlice (struct.t directory.DirEnt) (NewSlice (struct.t directory.DirEnt) #0) (struct.loadF directory.Directory "Dents" "dir") in
      ("dents", ErrOk)).

Definition Filesys__renameRemoveDst: val :=
  rec: "Filesys__renameRemoveDst" "f" "srcInum" "newDir" "dstName" :=
    let: ("dstInum", "ok") := directory.Directory__Lookup "newDir" "dstName" in
    (if: (~ "ok")
    then ErrOk
    else
      let: "srcInode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "srcInum" in
      let: "dstInode" := dirFs__GetInode (struct.loadF Filesys "fs" "f") "dstInum" in
      (if: (~ (simplefs.InodeType__IsValid (inode.Inode__GetType "dstInode")))
      then ErrOk
      else
        (if: ((inode.Inode__GetType "srcInode") = simplefs.FileType) && ((inode.Inode__GetType "dstInode") = simplefs.FileType)
        then
          let: "err" := Filesys__removeFile "f" "dstInum" in
          "err"
        else
          (if: ((inode.Inode__GetType "srcInode") = simplefs.DirType) && ((inode.Inode__GetType "dstInode") = simplefs.DirType)
          then
            let: "err" := Filesys__removeDir "f" "dstInum" in
            "err"
          else ErrExists)))).

Definition Filesys__renameSameDir: val :=
  rec: "Filesys__renameSameDir" "f" "parent" "oldName" "newName" :=
    let: "dir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "parent" in
    let: ("childInum", "ok") := directory.Directory__Lookup "dir" "oldName" in
    (if: (~ "ok")
    then ErrNoEnt
    else
      directory.Directory__Remove "dir" "oldName";;
      let: "err" := Filesys__renameRemoveDst "f" "childInum" "dir" "newName" in
      (if: "err" ≠ ErrOk
      then "err"
      else
        directory.Directory__Insert "dir" "newName" "childInum";;
        dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "parent" "dir";;
        ErrOk)).

Definition Filesys__Rename: val :=
  rec: "Filesys__Rename" "f" "oldParent" "oldName" "newParent" "newName" :=
    (if: (StringLength "newName") > directory.MAX_NAME_LEN
    then ErrNameTooLong
    else
      (if: "oldParent" = "newParent"
      then Filesys__renameSameDir "f" "oldParent" "oldName" "newName"
      else
        let: "oldDir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "oldParent" in
        let: ("childInum", "ok") := directory.Directory__Lookup "oldDir" "oldName" in
        (if: (~ "ok")
        then ErrNoEnt
        else
          let: "newDir" := dirFs__GetDirectory (struct.loadF Filesys "fs" "f") "newParent" in
          directory.Directory__Remove "oldDir" "oldName";;
          let: "err" := Filesys__renameRemoveDst "f" "childInum" "newDir" "newName" in
          (if: "err" ≠ ErrOk
          then "err"
          else
            directory.Directory__Insert "newDir" "newName" "childInum";;
            dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "oldParent" "oldDir";;
            dirFs__WriteDirectory (struct.loadF Filesys "fs" "f") "newParent" "newDir";;
            ErrOk)))).
