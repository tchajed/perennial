(* autogenerated from github.com/tchajed/simplefs/directory *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.tchajed.marshal.
From Goose Require github_com.tchajed.simplefs.

From Perennial.goose_lang Require Import ffi.disk_prelude.

Definition DirEnt := struct.decl [
  "Path" :: stringT;
  "Inum" :: simplefs.Inum
].

Definition DENT_SIZE : expr := #256.

Definition nameLen : expr := DENT_SIZE - #8.

Definition MAX_NAME_LEN : expr := nameLen - #1.

(* tillNullTerminator gives the non-null prefix of s *)
Definition tillNullTerminator: val :=
  rec: "tillNullTerminator" "s" :=
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "s")); (λ: <>, Skip) := λ: <>,
      (if: (SliceGet byteT "s" (![uint64T] "i")) = #(U8 0)
      then Break
      else
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Continue));;
    SliceTake "s" (![uint64T] "i").

Definition DirEnt__Encode: val :=
  rec: "DirEnt__Encode" "d" :=
    let: "buf" := ref_to (slice.T byteT) (StringToBytes (struct.get DirEnt "Path" "d")) in
    "buf" <-[slice.T byteT] (SliceAppendSlice byteT (![slice.T byteT] "buf") (NewSlice byteT (nameLen - (StringLength (struct.get DirEnt "Path" "d")))));;
    "buf" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "buf") (struct.get DirEnt "Inum" "d"));;
    ![slice.T byteT] "buf".

Definition decodeDirEnt: val :=
  rec: "decodeDirEnt" "b" :=
    let: "path" := ref_to stringT (StringFromBytes (tillNullTerminator (SliceTake "b" nameLen))) in
    let: ("i", <>) := marshal.ReadInt (SliceSkip byteT "b" nameLen) in
    struct.mk DirEnt [
      "Path" ::= ![stringT] "path";
      "Inum" ::= "i"
    ].

Definition Directory := struct.decl [
  "Dents" :: slice.T (struct.t DirEnt)
].

Definition Directory__Encode: val :=
  rec: "Directory__Encode" "d" :=
    let: "bytes" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    ForSlice (struct.t DirEnt) <> "dent" (struct.loadF Directory "Dents" "d")
      ("bytes" <-[slice.T byteT] (SliceAppendSlice byteT (![slice.T byteT] "bytes") (DirEnt__Encode "dent")));;
    ![slice.T byteT] "bytes".

Definition DecodeDirectory: val :=
  rec: "DecodeDirectory" "b" :=
    let: "dents" := ref_to (slice.T (struct.t DirEnt)) (NewSlice (struct.t DirEnt) #0) in
    let: "numEntries" := (slice.len "b") `quot` DENT_SIZE in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "numEntries"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "ent" := decodeDirEnt (SliceSubslice byteT "b" ((![uint64T] "i") * DENT_SIZE) (((![uint64T] "i") + #1) * DENT_SIZE)) in
      (if: (StringLength (struct.get DirEnt "Path" "ent")) > #0
      then
        "dents" <-[slice.T (struct.t DirEnt)] (SliceAppend (struct.t DirEnt) (![slice.T (struct.t DirEnt)] "dents") "ent");;
        Continue
      else Continue));;
    struct.new Directory [
      "Dents" ::= ![slice.T (struct.t DirEnt)] "dents"
    ].

Definition containsNull: val :=
  rec: "containsNull" "s" :=
    let: "nullFound" := ref_to boolT #false in
    let: "b" := StringToBytes "s" in
    ForSlice byteT <> "c" "b"
      ((if: "c" = #(U8 0)
      then "nullFound" <-[boolT] #true
      else #()));;
    ![boolT] "nullFound".

Definition Directory__Insert: val :=
  rec: "Directory__Insert" "d" "name" "inum" :=
    control.impl.Assert (~ (containsNull "name"));;
    control.impl.Assert ((StringLength "name") ≤ MAX_NAME_LEN);;
    let: "done" := ref_to boolT #false in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len (struct.loadF Directory "Dents" "d"))); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      (if: (struct.get DirEnt "Path" (SliceGet (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (![uint64T] "i"))) = "name"
      then
        let: "dent" := SliceRef (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (![uint64T] "i") in
        struct.storeF DirEnt "Inum" "dent" "inum";;
        "done" <-[boolT] #true;;
        Break
      else Continue));;
    (if: ![boolT] "done"
    then #()
    else
      struct.storeF Directory "Dents" "d" (SliceAppend (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (struct.mk DirEnt [
        "Path" ::= "name";
        "Inum" ::= "inum"
      ]));;
      #()).

Definition Directory__Remove: val :=
  rec: "Directory__Remove" "d" "name" :=
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len (struct.loadF Directory "Dents" "d"))); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      (if: (struct.get DirEnt "Path" (SliceGet (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (![uint64T] "i"))) = "name"
      then
        struct.storeF Directory "Dents" "d" (SliceAppendSlice (struct.t DirEnt) (SliceTake (struct.loadF Directory "Dents" "d") (![uint64T] "i")) (SliceSkip (struct.t DirEnt) (struct.loadF Directory "Dents" "d") ((![uint64T] "i") + #1)));;
        Break
      else Continue));;
    #().

Definition Directory__Lookup: val :=
  rec: "Directory__Lookup" "d" "name" :=
    let: "inum" := ref_to simplefs.Inum #0 in
    let: "found" := ref_to boolT #false in
    ForSlice (struct.t DirEnt) <> "dent" (struct.loadF Directory "Dents" "d")
      ((if: (~ (![boolT] "found")) && ((struct.get DirEnt "Path" "dent") = "name")
      then
        "inum" <-[simplefs.Inum] (struct.get DirEnt "Inum" "dent");;
        "found" <-[boolT] #true
      else #()));;
    (![simplefs.Inum] "inum", ![boolT] "found").

Definition Directory__Contains: val :=
  rec: "Directory__Contains" "d" "name" :=
    let: (<>, "ok") := Directory__Lookup "d" "name" in
    "ok".

Definition Directory__IsEmpty: val :=
  rec: "Directory__IsEmpty" "d" :=
    (slice.len (struct.loadF Directory "Dents" "d")) = #0.
