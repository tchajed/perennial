(* autogenerated from github.com/tchajed/simplefs/bitmap *)
From Perennial.goose_lang Require Import prelude.

From Perennial.goose_lang Require Import ffi.disk_prelude.

Definition Bitmap := struct.decl [
  "Data" :: slice.T byteT
].

Definition newBitmap: val :=
  rec: "newBitmap" "data" :=
    control.impl.Assume ((slice.len "data") < (#1 ≪ #56));;
    struct.mk Bitmap [
      "Data" ::= "data"
    ].

Definition NewBitmapFromBlocks: val :=
  rec: "NewBitmapFromBlocks" "d" "off" "numBlocks" :=
    let: "bitmapData" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 ("numBlocks" * disk.BlockSize)) in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "numBlocks"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      "bitmapData" <-[slice.T byteT] (SliceAppendSlice byteT (![slice.T byteT] "bitmapData") (disk.Read ("off" + (![uint64T] "i"))));;
      Continue);;
    newBitmap (![slice.T byteT] "bitmapData").

Definition Bitmap__Set: val :=
  rec: "Bitmap__Set" "b" "i" :=
    (if: "i" ≥ ((slice.len (struct.get Bitmap "Data" "b")) * #8)
    then Panic "out of bounds"
    else #());;
    let: "byteIndex" := "i" `quot` #8 in
    let: "bitIndex" := "i" `rem` #8 in
    SliceSet byteT (struct.get Bitmap "Data" "b") "byteIndex" ((SliceGet byteT (struct.get Bitmap "Data" "b") "byteIndex") `or` (#(U8 1) ≪ "bitIndex"));;
    #().

Definition Bitmap__Get: val :=
  rec: "Bitmap__Get" "b" "i" :=
    (if: "i" ≥ ((slice.len (struct.get Bitmap "Data" "b")) * #8)
    then Panic "out of bounds"
    else #());;
    let: "byteIndex" := "i" `quot` #8 in
    let: "bitIndex" := "i" `rem` #8 in
    ((SliceGet byteT (struct.get Bitmap "Data" "b") "byteIndex") `and` (#(U8 1) ≪ "bitIndex")) ≠ #(U8 0).

Definition Bitmap__Clear: val :=
  rec: "Bitmap__Clear" "b" "i" :=
    (if: "i" ≥ ((slice.len (struct.get Bitmap "Data" "b")) * #8)
    then Panic "out of bounds"
    else #());;
    let: "byteIndex" := "i" `quot` #8 in
    let: "bitIndex" := "i" `rem` #8 in
    SliceSet byteT (struct.get Bitmap "Data" "b") "byteIndex" ((SliceGet byteT (struct.get Bitmap "Data" "b") "byteIndex") `and` (~ (#(U8 1) ≪ "bitIndex")));;
    #().

Definition Bitmap__Len: val :=
  rec: "Bitmap__Len" "b" :=
    (slice.len (struct.get Bitmap "Data" "b")) * #8.

(* Write the bitmap to disk. This is a less-efficient API that writes the entire
   bitmap; a more sophisticated API would track which blocks are dirty and flush
   only those, and the bitmap would own that range of the disk. *)
Definition Bitmap__Write: val :=
  rec: "Bitmap__Write" "b" "d" "off" :=
    let: "numBlocks" := (slice.len (struct.get Bitmap "Data" "b")) `quot` disk.BlockSize in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "numBlocks"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      disk.Write ("off" + (![uint64T] "i")) (SliceSubslice byteT (struct.get Bitmap "Data" "b") ((![uint64T] "i") * disk.BlockSize) (((![uint64T] "i") + #1) * disk.BlockSize));;
      Continue);;
    #().
