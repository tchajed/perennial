(* autogenerated from github.com/tchajed/simplefs *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.disk_prelude.

(* bitmap.go *)

Definition BLK_BITS : expr := disk.BlockSize * #8.

Definition blockBitmap := struct.decl [
  "block" :: disk.blockT
].

(* TODO: should we use *blockBitmap or mutate the blocks directly? *)
Definition newBlockBitmap: val :=
  rec: "newBlockBitmap" "block" :=
    struct.new blockBitmap [
      "block" ::= "block"
    ].

Definition blockBitmap__Set: val :=
  rec: "blockBitmap__Set" "b" "i" :=
    (if: "i" ≥ BLK_BITS
    then Panic "out of bounds"
    else #());;
    let: "byteIndex" := "i" `quot` #8 in
    let: "bitIndex" := "i" `rem` #8 in
    SliceSet byteT (struct.loadF blockBitmap "block" "b") "byteIndex" ((SliceGet byteT (struct.loadF blockBitmap "block" "b") "byteIndex") `or` (#(U8 1) ≪ "bitIndex"));;
    #().

Definition blockBitmap__Get: val :=
  rec: "blockBitmap__Get" "b" "i" :=
    (if: "i" ≥ BLK_BITS
    then Panic "out of bounds"
    else #());;
    let: "byteIndex" := "i" `quot` #8 in
    let: "bitIndex" := "i" `rem` #8 in
    ((SliceGet byteT (struct.loadF blockBitmap "block" "b") "byteIndex") `and` (#(U8 1) ≪ "bitIndex")) ≠ #(U8 0).

Definition blockBitmap__Clear: val :=
  rec: "blockBitmap__Clear" "b" "i" :=
    (if: "i" ≥ BLK_BITS
    then Panic "out of bounds"
    else #());;
    let: "byteIndex" := "i" `quot` #8 in
    let: "bitIndex" := "i" `rem` #8 in
    SliceSet byteT (struct.loadF blockBitmap "block" "b") "byteIndex" ((SliceGet byteT (struct.loadF blockBitmap "block" "b") "byteIndex") `and` (~ (#(U8 1) ≪ "bitIndex")));;
    #().

Definition Bitmap := struct.decl [
  "blocks" :: slice.T ptrT
].

Definition NewBitmap: val :=
  rec: "NewBitmap" "blocks" :=
    let: "bitmapBlocks" := NewSlice ptrT (slice.len "blocks") in
    ForSlice (slice.T byteT) "i" "block" "blocks"
      (SliceSet ptrT "bitmapBlocks" "i" (newBlockBitmap "block"));;
    struct.mk Bitmap [
      "blocks" ::= "bitmapBlocks"
    ].

Definition Bitmap__BlockNum: val :=
  rec: "Bitmap__BlockNum" "b" "i" :=
    "i" `quot` BLK_BITS.

Definition Bitmap__Block: val :=
  rec: "Bitmap__Block" "b" "i" :=
    struct.loadF blockBitmap "block" (SliceGet ptrT (struct.get Bitmap "blocks" "b") (Bitmap__BlockNum "b" "i")).

Definition Bitmap__Set: val :=
  rec: "Bitmap__Set" "b" "i" :=
    let: "blockNum" := Bitmap__BlockNum "b" "i" in
    let: "bitIndex" := "i" `rem` BLK_BITS in
    blockBitmap__Set (SliceGet ptrT (struct.get Bitmap "blocks" "b") "blockNum") "bitIndex";;
    #().

Definition Bitmap__Get: val :=
  rec: "Bitmap__Get" "b" "i" :=
    let: "blockNum" := Bitmap__BlockNum "b" "i" in
    let: "bitIndex" := "i" `rem` BLK_BITS in
    blockBitmap__Get (SliceGet ptrT (struct.get Bitmap "blocks" "b") "blockNum") "bitIndex".

Definition Bitmap__Clear: val :=
  rec: "Bitmap__Clear" "b" "i" :=
    let: "blockNum" := Bitmap__BlockNum "b" "i" in
    let: "bitIndex" := "i" `rem` BLK_BITS in
    blockBitmap__Clear (SliceGet ptrT (struct.get Bitmap "blocks" "b") "blockNum") "bitIndex";;
    #().

Definition Bitmap__Len: val :=
  rec: "Bitmap__Len" "b" :=
    (slice.len (struct.get Bitmap "blocks" "b")) * BLK_BITS.

(* consts.go *)

Definition Inum: ty := uint64T.

Definition ROOT_INUM : expr := #1.

Definition InodeType: ty := uint32T.

Definition Invalid : expr := #(U32 0).

Definition DirType : expr := #(U32 1).

Definition FileType : expr := #(U32 2).

Definition InodeType__IsValid: val :=
  rec: "InodeType__IsValid" "t" :=
    "t" ≠ Invalid.

Definition INODE_SIZE : expr := #128.

Definition INODES_PER_BLOCK : expr := disk.BlockSize `quot` INODE_SIZE.

(* dir.go *)

Definition DirEnt := struct.decl [
  "Path" :: stringT;
  "Inum" :: Inum
].

Definition DENT_SIZE : expr := #256.

Definition nameLen : expr := DENT_SIZE - #8.

Definition MAX_NAME_LEN : expr := nameLen - #1.

(* tillNullTerminator gives the non-null prefix of s *)
Definition tillNullTerminator: val :=
  rec: "tillNullTerminator" "s" :=
    let: "nullIndex" := ref (zero_val ptrT) in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len "s")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      (if: ((![ptrT] "nullIndex") = #null) && ((SliceGet byteT "s" (![uint64T] "i")) = #(U8 0))
      then
        "nullIndex" <-[ptrT] "i";;
        Continue
      else Continue));;
    (if: (![ptrT] "nullIndex") = #null
    then "s"
    else SliceTake "s" (![uint64T] (![ptrT] "nullIndex"))).

Definition DirEnt__Encode: val :=
  rec: "DirEnt__Encode" "d" :=
    let: "buf" := ref_to (slice.T byteT) (StringToBytes (struct.loadF DirEnt "Path" "d")) in
    "buf" <-[slice.T byteT] (SliceAppendSlice byteT (![slice.T byteT] "buf") (NewSlice byteT (nameLen - (StringLength (struct.loadF DirEnt "Path" "d")))));;
    "buf" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "buf") (struct.loadF DirEnt "Inum" "d"));;
    ![slice.T byteT] "buf".

Definition decodeDirEnt: val :=
  rec: "decodeDirEnt" "b" :=
    let: "path" := ref_to stringT (StringFromBytes (tillNullTerminator (SliceTake "b" nameLen))) in
    let: ("i", <>) := marshal.ReadInt (SliceSkip byteT "b" nameLen) in
    struct.mk DirEnt [
      "Path" ::= ![stringT] "path";
      "Inum" ::= "i"
    ].

Definition Directory := struct.decl [
  "Dents" :: slice.T (struct.t DirEnt)
].

Definition Directory__Encode: val :=
  rec: "Directory__Encode" "d" :=
    let: "bytes" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    ForSlice (struct.t DirEnt) <> "dent" (struct.loadF Directory "Dents" "d")
      ("bytes" <-[slice.T byteT] (SliceAppendSlice byteT (![slice.T byteT] "bytes") (DirEnt__Encode "dent")));;
    ![slice.T byteT] "bytes".

Definition DecodeDirectory: val :=
  rec: "DecodeDirectory" "b" :=
    let: "dents" := ref_to (slice.T (struct.t DirEnt)) (NewSlice (struct.t DirEnt) #0) in
    let: "numEntries" := (slice.len "b") `quot` DENT_SIZE in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "numEntries"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "ent" := decodeDirEnt (SliceSubslice byteT "b" ((![uint64T] "i") * DENT_SIZE) (((![uint64T] "i") + #1) * DENT_SIZE)) in
      (if: (StringLength (struct.get DirEnt "Path" "ent")) > #0
      then
        "dents" <-[slice.T (struct.t DirEnt)] (SliceAppend (struct.t DirEnt) (![slice.T (struct.t DirEnt)] "dents") "ent");;
        Continue
      else Continue));;
    struct.mk Directory [
      "Dents" ::= ![slice.T (struct.t DirEnt)] "dents"
    ].

Definition containsNull: val :=
  rec: "containsNull" "s" :=
    let: "nullFound" := ref_to boolT #false in
    let: "b" := StringToBytes "s" in
    ForSlice byteT <> "c" "b"
      ((if: "c" = #(U8 0)
      then "nullFound" <-[boolT] #true
      else #()));;
    ![boolT] "nullFound".

Definition Directory__Insert: val :=
  rec: "Directory__Insert" "d" "name" "inum" :=
    control.impl.Assert (~ (containsNull "name"));;
    control.impl.Assert ((StringLength "name") ≤ MAX_NAME_LEN);;
    let: "done" := ref_to boolT #false in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len (struct.loadF Directory "Dents" "d"))); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      (if: (struct.get DirEnt "Path" (SliceGet (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (![uint64T] "i"))) = "name"
      then
        let: "dent" := SliceRef (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (![uint64T] "i") in
        struct.storeF DirEnt "Inum" "dent" "inum";;
        "done" <-[boolT] #true;;
        Break
      else Continue));;
    (if: ![boolT] "done"
    then #()
    else
      struct.storeF Directory "Dents" "d" (SliceAppend (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (struct.mk DirEnt [
        "Path" ::= "name";
        "Inum" ::= "inum"
      ]));;
      #()).

Definition Directory__Remove: val :=
  rec: "Directory__Remove" "d" "name" :=
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len (struct.loadF Directory "Dents" "d"))); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      (if: (struct.get DirEnt "Path" (SliceGet (struct.t DirEnt) (struct.loadF Directory "Dents" "d") (![uint64T] "i"))) = "name"
      then
        struct.storeF Directory "Dents" "d" (SliceAppendSlice (struct.t DirEnt) (SliceTake (struct.loadF Directory "Dents" "d") (![uint64T] "i")) (SliceSkip (struct.t DirEnt) (struct.loadF Directory "Dents" "d") ((![uint64T] "i") + #1)));;
        Break
      else Continue));;
    #().

Definition Directory__Lookup: val :=
  rec: "Directory__Lookup" "d" "name" :=
    let: "inum" := ref_to Inum #0 in
    let: "found" := ref_to boolT #false in
    ForSlice (struct.t DirEnt) <> "dent" (struct.loadF Directory "Dents" "d")
      ((if: (~ (![boolT] "found")) && ((struct.get DirEnt "Path" "dent") = "name")
      then
        "inum" <-[Inum] (struct.get DirEnt "Inum" "dent");;
        "found" <-[boolT] #true
      else #()));;
    (![Inum] "inum", ![boolT] "found").

Definition Directory__Contains: val :=
  rec: "Directory__Contains" "d" "name" :=
    let: (<>, "ok") := Directory__Lookup "d" "name" in
    "ok".

Definition Directory__IsEmpty: val :=
  rec: "Directory__IsEmpty" "d" :=
    (slice.len (struct.loadF Directory "Dents" "d")) = #0.
